#1 - 网络内，节点中所有应用之间的通讯都使用Payload 报文，报文有如下四种：
      基于链接的：（有连接）报文在已建立的链接上传输
      组播的：（有连接）报文被发送到多个目的地址
      指定服务类型的：（无连接）无链接的报文，报文内包含{type,instance}这样的字段来标识目的地址
      指定服务地址的：（无连接）无链接的报文，报文内包含<Z.C.N:reference>这样的字段来标识目的地址
      
#2 - 报文头的尺寸
      基于链接的：24字节
      组播的：40字节
      指定服务类型的：44字节
      指定服务地址的：32字节
      
#3 - 报文结构
      略
      
#4 - 报文的分发
      略
      
#5 - 无连接的通讯
      无连接通讯有两种：指定服务类型的，指定服务地址的。
      无连接通讯的好处有三个：1.不需要建立连接的过程；
                            2.可以实现“单到多”和“多到单”的通讯；
                            3.无连接，更灵活。
      无连接通讯的缺点：没法进行流量控制，某个节点很可能会被来自多个源的大流量击垮。
      
#6 - 有连接的通讯
      用户的连接被设计的比较轻量级，因为对于TIPC来说，频繁建立连接和断开连接很常见，轻量级用来减少开销。
      
  #6.1 - 连接的建立
        TIPC协议没定义如何建立连接，只定义了如何监视和如何抛弃。建立连接属于用户实现部分，TIPC只给出了大致的思路，而且，使用的报文都是payload报文
        比如下面两个例子：
        1、用户定义
 -------------------                -------------------
| Client            |              | Server            |
|                   |              |                   |
| (3)create(cport)  |              | (1)create(suport) |
| (4)send(type:17,  |------------->0 (2)bind(type: 17, |
|         inst: 7)  0<------+      |\        lower:0   |
| (8)lconnect(sport)|       |      | \       upper:9)  |
|                   |       |      | /                 |
|                   |       |      |/(5)create(sport)  |
|                   |       +------0 (6)lconnect(cport)|
|                   |              | (7)send()         |
 -------------------                -------------------
        2、TIPC提供接口，供用户调用来定义
 --------------------                -------------------
| Client             |              | Server            |
|                    |              | (1)create(suport) |
| (4)create(cport)   |   "SYN"      | (2)bind(type: 17, |
| (5)connect(type:17,|------------->0         lower:0   |
| (9)        inst: 7)0<------+     /|         upper:9)  |
|                    |       |    / | (3)accept()       |
|                    |    (7)|    \ | (8)               |
|                    |       |  (6)\|                   |
|                    |       +------0 (9)recv()         |
|                    |      "SYN"   |                   |
 --------------------                -------------------
        
  #6.2 - 连接的关闭
          和连接的建立一样，也没有定义连接的关闭，同时也提供了两个途径让用户自定义：
        1、自定义payload报文         
       -------------------                -------------------
      | Client            |              | Server            |
      |                   |              |                   |
      |                   |              |                   |
      |          lclose() 0              0 lclose()          |
      |                   |              |                   |
      |                   |              |                   |
      |                   |              |                   |
       -------------------                -------------------
        2、TIPC提供接口，供用户调用来定义
        
       --------------------                -------------------
      | Client             |              | Server            |
      |                    |    "FIN"     |                   |
      |          (1)close()0------------->0(2)close()         |
      |                    |              |                   |
      |                    |              |                   |
      |                    |              |                   |
       --------------------                -------------------

  #6.3 - 连接的抛弃
      见官方文档
      
  #6.4 - 连接的监视
      连接会自发地检测连接的双端是否依旧存在和状态是否正常。
      每当连接建立，那么连接的双端都会创建一个“定时器”，用来检查连接的状态。
      默认情况下，每一小时，连接的双端都会发送一个CONN_PROBE的报文出来，这个探测（peobe）报文有两个目的：1、让发送者确认，当前连接还是能用的；
      2、用来查询接收方的当前状态。
      
      probe报文和probe的反馈报文格式如下：
      
---------------------------------------------------------------------
|                              |        Received Message Type       |
|                              |-----------------+------------------|
|                              |   CONN_PROBE    | CONN_PROBE_REPLY |
|                              |                 |                  |
|==============================|====================================|
|     |             Multi-hop  |        CRITICAL_IMPORANCE+         |
|     |             seqno wrong|        TIPC_COMM_ERROR             |
|     |            ------------|-----------------+------------------|
|     | Connected   Multi-hop  |                 |                  |
|     | to sender   seqno ok   |                 |                  |
|     | port       ------------|                 |                  |
|     |             Single hop | CONN_PROBE_REPLY|  No Response     |
|     |------------------------|                 |                  |
|     | Not connected,         |                 |                  |
|Rece-| not bound,             |                 |                  |
|ving |------------------------|-----------------+------------------|
|Port | Connected to           |                                    |
|State| other port             |        CRITICAL_IMPORANCE+         |
|     |------------------------|        TIPC_NOT_CONNECTED          |
|     | Bound to               |                                    |
|     | port name sequence     |                                    |
|     |------------------------|------------------------------------|
|     | Recv. node available,  |        CRITICAL_IMPORANCE+         |
|     | recv. port non-existent|        TIPC_NO_REMOTE_PORT         |
|     |------------------------|------------------------------------|
|     | Receiving node         |        CRITICAL_IMPORANCE+         |
|     | unavailable            |        TIPC_NO_REMOTE_NODE         |
---------------------------------------------------------------------
        接收方一收到probe报文，就要回复另一个probe报文作为应答
      
  #6.5 - 连接的管理
    见官方
  
#7 - 流量控制
    1.发送方持有一个计数器，这个计数器在每次成功发送一个消息后+1（不是在收到对端确认后，仅仅是发送成功）。
    2.方也持有一个计数器，这个计数器在接收方每次把消息传送给应用层后+1（不是在收到发送端发送报文后，仅仅是面向应用层用户）。同时，接收方
    定时（或者其他时间），会反馈一个包含数字N的报文给发送方，告知对方我收到了N个包。
    3.发送方在收到包含N值得报文后，把发送计数器减去N。
    4.每次在发送方想发数据的时候，都要检查一下发送计数器，如果超过了限定值，那么就不能在发了，此时要排队等。
          
          注：这个N的值一般大于200个报文，而限定值一般是2N。所以一般都是一次性把计数器减去上限的一半。

#8 - 顺序检查
    略







                            
